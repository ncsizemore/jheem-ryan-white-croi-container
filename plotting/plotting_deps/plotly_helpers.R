# plotly_helpers.R
# Missing plotly helper functions for plot rendering

#' Simplify Plotly Legend
#'
#' Post-process plotly figure to simplify legend when multiple simulation sets
#' are plotted. Keeps only one legend entry per simulation set (removes duplicates
#' from different strata) and removes non-simulation traces from legend.
#'
#' @param plotly_fig The plotly figure object generated by ggplotly.
#' @param sim_names A character vector of the expected simulation set names.
#' @return The modified plotly figure object.
simplify_plotly_legend <- function(plotly_fig, sim_names) {
  tryCatch(
    {
      if (!is.null(plotly_fig$x$data) && length(plotly_fig$x$data) > 0) {
        num_traces <- length(plotly_fig$x$data)

        kept_items <- list() # Store {index: i, name: sim_name} for traces to keep/rename
        indices_to_hide <- c()
        sim_names_found <- character(0) # Track which sim_names we've kept a trace for

        if (length(sim_names) >= 1) {
          for (i in 1:num_traces) {
            trace <- plotly_fig$x$data[[i]]
            trace_name <- trace$name

            # Default showlegend is TRUE if NULL
            show_legend_flag <- if (is.null(trace$showlegend)) TRUE else trace$showlegend

            # Skip traces already hidden (e.g., ribbons)
            if (!show_legend_flag) {
              next
            }

            is_sim_trace <- FALSE
            target_sim_name <- NULL

            # Check if trace name matches any sim_name pattern
            for (sim_name in sim_names) {
              # Pattern: Starts with "(," followed by the sim_name
              pattern_start <- paste0("(,", sim_name)
              # Use fixed=TRUE for literal matching, avoid regex issues with parentheses in sim_name
              if (startsWith(trace_name, pattern_start)) {
                is_sim_trace <- TRUE
                target_sim_name <- sim_name
                break # Found the sim_name for this trace
              }
            }

            if (is_sim_trace) {
              # Check if we already kept a trace for this simulation set
              if (!(target_sim_name %in% sim_names_found)) {
                # Keep this one
                kept_items[[length(kept_items) + 1]] <- list(index = i, name = target_sim_name)
                sim_names_found <- c(sim_names_found, target_sim_name)
              } else {
                # Duplicate simulation trace (different stratum), hide it
                indices_to_hide <- c(indices_to_hide, i)
              }
            } else {
              # Not a simulation trace (e.g., data points), hide it
              indices_to_hide <- c(indices_to_hide, i)
            }
          } # End trace loop

          # Apply styling: Rename kept traces
          if (length(kept_items) > 0) {
            for (item in kept_items) {
              plotly_fig <- plotly::style(plotly_fig, name = item$name, traces = item$index)
            }
          }

          # Apply styling: Hide other traces
          if (length(indices_to_hide) > 0) {
            plotly_fig <- plotly::style(plotly_fig, showlegend = FALSE, traces = indices_to_hide)
          }

          # Remove overall legend title
          if (!is.null(plotly_fig$x$layout$legend$title)) {
            plotly_fig$x$layout$legend$title$text <- NULL
          }
        }
      }
    },
    error = function(e) {
      warning(paste("Error during dynamic legend simplification:", conditionMessage(e)))
    }
  )
  return(plotly_fig)
}

#' Adjust Plotly Facet Labels
#'
#' Workaround for ggplotly clipping the top of multi-line facet labels when
#' strip.placement = "outside". Manually shifts the y-coordinate of the
#' Plotly annotations corresponding to the facet labels downwards slightly.
#'
#' @param plotly_fig The plotly figure object generated by ggplotly.
#' @param adjustment_offset The amount to shift labels down (as fraction of plot height).
#' @return The modified plotly figure object.
adjust_plotly_facet_labels <- function(plotly_fig, adjustment_offset = 0.01) {
  tryCatch(
    {
      if (!is.null(plotly_fig$x$layout$annotations) && length(plotly_fig$x$layout$annotations) > 0) {
        adjusted_count <- 0
        for (i in 1:length(plotly_fig$x$layout$annotations)) {
          # Identify facet labels (heuristic: yanchor='bottom', yref='paper')
          annotation <- plotly_fig$x$layout$annotations[[i]]
          if (!is.null(annotation$yanchor) && annotation$yanchor == "bottom" &&
            !is.null(annotation$yref) && annotation$yref == "paper") {
            original_y <- annotation$y
            plotly_fig$x$layout$annotations[[i]]$y <- original_y - adjustment_offset
            adjusted_count <- adjusted_count + 1
          }
        }
      }
    },
    error = function(e) {
      warning(paste("Error during facet label adjustment:", conditionMessage(e)))
    }
  )
  return(plotly_fig)
}

#' Create a Labeller Function for Facets
#'
#' Generates a labeller function compatible with ggplot2::facet_wrap that uses
#' provided mappings to translate internal facet values to user-friendly labels.
#'
#' @param label_mappings A nested list structure from visualization config
#' @param original_facet_vars A character vector of the original facet variable names
#' @return A function suitable for the `labeller` argument of `facet_wrap`
create_custom_facet_labeller <- function(label_mappings, original_facet_vars) {
  if (is.null(label_mappings)) {
    return(NULL)
  }

  # Simple fallback labeller that returns values as-is
  labeller_func <- function(labels_df) {
    # Return the labels as-is for now
    return(labels_df)
  }
  
  return(labeller_func)
}

cat("ðŸ“¦ Plotly helper functions loaded\n")
