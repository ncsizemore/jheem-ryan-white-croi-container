# src/ui/components/common/display/plot_panel.R

library(plotly) # Add plotly library
library(shiny)
library(ggplot2)

# Container adaptation: Comment out sources that are either loaded elsewhere or need path fixes
# source("src/data/loaders/baseline_loader.R") # Using baseline_loading.R instead
source("plotting/plotting_deps/plot_customizer.R") # Fixed path for container
# source("src/utils/plotting_local.R") # Already loaded by batch_plot_generator.R
# source("src/utils/simplot_local_mods.R") # Already loaded by batch_plot_generator.R
# Assuming config loader is sourced elsewhere or available
# source("src/ui/config/load_config.R")
# Assuming visualization manager is sourced elsewhere
# source("src/ui/state/visualization.R")
# Assuming control manager is sourced elsewhere
# source("src/ui/components/common/plot_controls/control_manager.R") # Adjust path if needed
# Assuming error boundaries are sourced elsewhere
# source("src/ui/components/common/errors/boundaries.R") # Adjust path if needed
# Assuming store is available via get_store()
# source("src/ui/state/store.R") # Adjust path if needed

# --- Helper Functions for Plotly Workarounds ---

#' Simplify Plotly Legend
#'
#' Workaround for ggplotly creating excessive legend entries.
#' Dynamically identifies the first trace for each simulation set based on its
#' name pattern, renames it, hides legend entries for subsequent traces of the
#' same set and other non-simulation traces, and removes the legend title.
#'
#' @param plotly_fig The plotly figure object generated by ggplotly.
#' @param sim_names A character vector of the expected simulation set names.
#' @return The modified plotly figure object.
simplify_plotly_legend <- function(plotly_fig, sim_names) {
  tryCatch(
    {
      if (!is.null(plotly_fig$x$data) && length(plotly_fig$x$data) > 0) {
        num_traces <- length(plotly_fig$x$data)

        kept_items <- list() # Store {index: i, name: sim_name} for traces to keep/rename
        indices_to_hide <- c()
        sim_names_found <- character(0) # Track which sim_names we've kept a trace for

        if (length(sim_names) >= 1) {
          for (i in 1:num_traces) {
            trace <- plotly_fig$x$data[[i]]
            trace_name <- trace$name

            # Default showlegend is TRUE if NULL
            show_legend_flag <- if (is.null(trace$showlegend)) TRUE else trace$showlegend

            # Skip traces already hidden (e.g., ribbons)
            if (!show_legend_flag) {
              next
            }

            is_sim_trace <- FALSE
            target_sim_name <- NULL

            # Check if trace name matches any sim_name pattern
            for (sim_name in sim_names) {
              # Pattern: Starts with "(," followed by the sim_name
              pattern_start <- paste0("(,", sim_name)
              # Use fixed=TRUE for literal matching, avoid regex issues with parentheses in sim_name
              if (startsWith(trace_name, pattern_start)) {
                is_sim_trace <- TRUE
                target_sim_name <- sim_name
                break # Found the sim_name for this trace
              }
            }

            if (is_sim_trace) {
              # Check if we already kept a trace for this simulation set
              if (!(target_sim_name %in% sim_names_found)) {
                # Keep this one
                kept_items[[length(kept_items) + 1]] <- list(index = i, name = target_sim_name)
                sim_names_found <- c(sim_names_found, target_sim_name)
              } else {
                # Duplicate simulation trace (different stratum), hide it
                indices_to_hide <- c(indices_to_hide, i)
              }
            } else {
              # Not a simulation trace (e.g., data points), hide it
              indices_to_hide <- c(indices_to_hide, i)
            }
          } # End trace loop

          # Apply styling: Rename kept traces
          if (length(kept_items) > 0) {
            for (item in kept_items) {
              plotly_fig <- plotly::style(plotly_fig, name = item$name, traces = item$index)
            }
            # kept_indices_str <- paste(sapply(kept_items, `[[`, "index"), collapse = ", ") # Keep commented
            # print(paste("[PLOT PANEL - ggplotly] Renamed legend entries for traces:", kept_indices_str)) # Keep commented
          }

          # Apply styling: Hide other traces
          if (length(indices_to_hide) > 0) {
            plotly_fig <- plotly::style(plotly_fig, showlegend = FALSE, traces = indices_to_hide)
            # print(paste("[PLOT PANEL - ggplotly] Hid legend entries for traces:", paste(indices_to_hide, collapse = ", "))) # Keep commented
          }

          # Remove overall legend title
          if (!is.null(plotly_fig$x$layout$legend$title)) {
            plotly_fig$x$layout$legend$title$text <- NULL
            # print("[PLOT PANEL - ggplotly] Removed legend title.") # Keep commented
          }
        } else {
          # print("[PLOT PANEL - ggplotly] No simulation set names found to simplify legend.") # Keep commented
        }
      } else {
        # print("[PLOT PANEL - ggplotly] No traces found to simplify legend.") # Keep commented
      }
    },
    error = function(e) {
      warning(paste("[PLOT PANEL - ggplotly] Error during dynamic legend simplification:", conditionMessage(e))) # Keep warning
    }
  )
  return(plotly_fig)
}


#' Adjust Plotly Facet Labels
#'
#' Workaround for ggplotly clipping the top of multi-line facet labels when
#' strip.placement = "outside". Manually shifts the y-coordinate of the
#' Plotly annotations corresponding to the facet labels downwards slightly.
#' Relies on identifying annotations via yanchor='bottom' and yref='paper'.
#'
#' @param plotly_fig The plotly figure object generated by ggplotly.
#' @param adjustment_offset The amount to shift labels down (as fraction of plot height).
#' @return The modified plotly figure object.
adjust_plotly_facet_labels <- function(plotly_fig, adjustment_offset = 0.01) {
  tryCatch(
    {
      if (!is.null(plotly_fig$x$layout$annotations) && length(plotly_fig$x$layout$annotations) > 0) {
        adjusted_count <- 0
        for (i in 1:length(plotly_fig$x$layout$annotations)) {
          # Identify facet labels (heuristic: yanchor='bottom', yref='paper')
          annotation <- plotly_fig$x$layout$annotations[[i]]
          if (!is.null(annotation$yanchor) && annotation$yanchor == "bottom" &&
            !is.null(annotation$yref) && annotation$yref == "paper") {
            original_y <- annotation$y
            plotly_fig$x$layout$annotations[[i]]$y <- original_y - adjustment_offset
            adjusted_count <- adjusted_count + 1
            # print(paste("Adjusted annotation", i, "y from", original_y, "to", plotly_fig$x$layout$annotations[[i]]$y)) # Keep commented
          }
        }
        # print(paste("[PLOT PANEL - ggplotly] Manually adjusted y-coordinate for", adjusted_count, "facet label annotations.")) # Keep commented
      } else {
        # print("[PLOT PANEL - ggplotly] No annotations found to adjust.") # Keep commented
      }
    },
    error = function(e) {
      warning(paste("[PLOT PANEL - ggplotly] Error during facet label adjustment:", conditionMessage(e)))
    }
  )
  return(plotly_fig)
}

# --- End Helper Functions ---
# --- Helper Function for Creating Custom Facet Labeller ---

#' Create a Labeller Function for Facets
#'
#' Generates a labeller function compatible with ggplot2::facet_wrap that uses
#' provided mappings to translate internal facet values to user-friendly labels.
#' It handles the renaming of facet variables (e.g., 'sex' to 'facet.by1')
#' done by simplot_local.
#'
#' @param label_mappings A nested list structure from visualization config,
#'   e.g., list(sex=list(male="Male", female="Female"), risk=list(...)).
#' @param original_facet_vars A character vector of the original facet variable
#'   names passed to simplot_local (e.g., c("sex", "risk")).
#' @return A function suitable for the `labeller` argument of `facet_wrap`.
#'         Returns NULL if label_mappings is NULL.
create_custom_facet_labeller <- function(label_mappings, original_facet_vars) {
  if (is.null(label_mappings)) {
    return(NULL)
  }

  # The actual labeller function ggplot2 calls
  labeller_func <- function(labels_df) {
    # labels_df is a data frame where columns are the facet variables
    # as used in the facet_wrap formula (e.g., outcome.display.name, facet.by1)
    # and rows are the unique combinations of their values.

    mapped_labels_df <- labels_df # Start with original labels

    # --- Map outcome.display.name (Optional - if mappings exist) ---
    # Example: if you had mappings for outcome names themselves
    # if ("outcome.display.name" %in% names(labels_df) && !is.null(label_mappings[["outcome"]])) {
    #   mapped_labels_df$outcome.display.name <- sapply(labels_df$outcome.display.name, function(val) {
    #     label_mappings[["outcome"]][[as.character(val)]] %||% as.character(val)
    #   })
    # }

    # --- Map facet.by1, facet.by2, etc. using original_facet_vars ---
    if (!is.null(original_facet_vars) && length(original_facet_vars) > 0) {
      for (i in seq_along(original_facet_vars)) {
        original_var_name <- original_facet_vars[i] # e.g., "sex"
        generated_col_name <- paste0("facet.by", i) # e.g., "facet.by1"

        # Check if the generated column exists in the labels dataframe
        # and if we have mappings for the original variable name
        if (generated_col_name %in% names(labels_df) &&
          !is.null(label_mappings[[original_var_name]])) {
          # Apply the mapping lookup to each value in the column
          mapped_labels_df[[generated_col_name]] <- sapply(
            labels_df[[generated_col_name]],
            function(val) {
              # Lookup: label_mappings$sex$`msm` -> "MSM"
              # Fallback to original value if no mapping found
              label_mappings[[original_var_name]][[as.character(val)]] %||% as.character(val)
            }
          )
        }
      }
    }
    return(mapped_labels_df)
  }

  # Return the function ggplot2 needs
  return(labeller_func)
}

# --- End Helper Function ---

parse_template <- function(template, values) {
  if (is.null(template) || length(template) == 0) {
    return(template)
  }
  result <- template
  for (name in names(values)) {
    if (!is.null(values[[name]])) {
      pattern <- paste0("\\{", name, "\\}")
      result <- gsub(pattern, values[[name]], result)
    }
  }
  return(result)
}

# Add simplify_legend argument with a default, even if not used internally for now
create_style_manager_from_config <- function(vis_config, simplify_legend = FALSE) {
  default_style_manager <- tryCatch(get.default.style.manager(), error = function(e) {
    warning("Default style manager error: ", e$message)
    NULL
  })

  if (is.null(vis_config) || is.null(vis_config$style_manager)) {
    return(default_style_manager)
  }

  style_config <- vis_config$style_manager
  params <- list(color.sim.by = "simset", linetype.sim.by = "stratum")

  if (!is.null(style_config$general)) {
    for (param_name in names(style_config$general)) {
      params[[param_name]] <- style_config$general[[param_name]]
    }
  }

  if (!is.null(style_config$intervention$color) && !is.null(style_config$baseline$color)) {
    custom_palette <- function(n) {
      pal_jama_safe <- tryCatch(ggsci::pal_jama(), error = function(e) scales::hue_pal())
      if (n <= 2) {
        return(c(style_config$intervention$color, style_config$baseline$color))
      } else {
        c(style_config$intervention$color, style_config$baseline$color, pal_jama_safe(n - 2))
      }
    }
    params$sim.palette <- custom_palette
  }

  if (!is.null(style_config$use_different_line_types)) {
    if (style_config$use_different_line_types) {
      params$linetype.sim.by <- "simset"
    } else {
      if (!("linetype.sim.by" %in% names(style_config$general))) {
        params$linetype.sim.by <- "stratum"
      }
    }
  }

  if (exists("create.style.manager") && is.function(create.style.manager)) {
    do.call(create.style.manager, params)
  } else {
    warning("create.style.manager not found.")
    default_style_manager
  }
}

create_plot_panel <- function(id, type = "static") {
  ns <- NS(id)

  tags$div(
    class = paste0("main-panel main-panel-plot ", id, "-plot-panel"),
    tags$input(id = ns("visualization_state"), type = "hidden", value = "hidden"),
    tags$input(id = ns("display_type"), type = "hidden", value = "plot"),
    conditionalPanel(
      condition = sprintf(
        "input['%s'] === 'visible' && input['%s'] === 'plot'",
        ns("visualization_state"),
        ns("display_type")
      ),
      tags$div(
        class = "panel-container panel-section", # Added panel-section for card styling
        tags$div(
          class = "panel-content",
          # Add UI output for the title and download button container
          tags$div(
            style = "display: flex; justify-content: space-between; align-items: center;",
            uiOutput(ns("plot_title_ui")),
            actionButton(ns("downloadPlotClient"), label = icon("download"), title = "Download Plot", class = "btn-jheem-primary")
          ),
          # Use uiOutput for dynamic plot rendering
          uiOutput(ns("plot_output_ui"))
        )
      )
    ),
    tags$div(
      class = "plot-error error",
      textOutput(ns("plot_error_message"), inline = FALSE)
    ),
    uiOutput(ns("error_display"))
  )
}

# Add scenario_options_config argument with a default NULL
plot_panel_server <- function(id, settings, scenario_options_config = NULL) {
  moduleServer(id, function(input, output, session) {
    ns <- session$ns
    store <- get_store()
    req(store)

    direct_error_message <- reactiveVal(NULL)
    output$plot_error_message <- renderText({
      direct_error_message()
    })

    vis_manager <- create_visualization_manager(session, id, ns("visualization"))
    control_manager <- create_control_manager(session, id, ns("controls"), settings) # Uses new stateless manager

    validation_boundary <- create_validation_boundary(
      session, output, id, "validation",
      state_manager = vis_manager
    )
    plot_boundary <- create_plot_boundary(
      session, output, id, "plot",
      state_manager = vis_manager
    )
    sim_boundary <- create_simulation_boundary(
      session, output, id, "simulation",
      state_manager = vis_manager
    )

    # Reactive value to store the settings used for the last successful plot render
    last_rendered_settings <- reactiveVal(NULL)

    # Define reactive dependencies for cache key *outside* renderPlot
    current_settings_reactive <- reactive({
      control_manager$get_settings()
    })
    current_sim_id_reactive <- reactive({
      store$get_current_simulation_id(id)
    })

    # --- Dynamic UI for Plot Output ---
    output$plot_output_ui <- renderUI({
      vis_config <- tryCatch(get_component_config("visualization"), error = function(e) NULL)
      backend <- vis_config$plotting_backend %||% "ggplot" # Default to ggplot

      if (backend == "plotly") {
        # Removed fixed height to allow dynamic sizing from plotly object
        plotlyOutput(ns("mainPlotly"), width = "100%")
      } else if (backend == "ggplotly") {
        # Use plotlyOutput for ggplotly with a scrollable container
        tags$div(
          id = ns("ggplotly-container"),
          style = "height: 700px; overflow-y: auto;", # Fixed height container with scrolling
          plotlyOutput(ns("mainGGPlotly"), width = "100%")
        )
      } else {
        # Keep ggplot height for now, assuming it behaves differently
        plotOutput(ns("mainPlot"), height = "600px", width = "100%")
      }
    })

    # --- Reactive Expression for Plot Title ---
    output$plot_title_ui <- renderUI({
      plot_data <- plot_data_reactive() # Depends on the main reactive
      req(!isTRUE(plot_data$error)) # Don't render title if data fetch failed

      # Construct title based on location (mimicking simplot's default)
      title_text <- "Plot" # Default
      location <- plot_data$sim_settings$location
      if (!is.null(location) && exists("get.location.name")) {
        location_name <- tryCatch(get.location.name(location), error = function(e) location)
        title_text <- paste0(location_name, " (", location, ")")
      } else if (!is.null(location)) {
        title_text <- location # Fallback if get.location.name doesn't exist
      }

      tags$h4(class = "plot-title", title_text) # Render as an h4 tag
    })

    # --- Reactive Expression for Data Fetching and Preparation ---
    plot_data_reactive <- reactive({
      # --- Load Full Page Config --- REMOVED - Use global PRERUN_CONFIG/CUSTOM_CONFIG ---
      # # Ensure get_page_complete_config is available
      # req(exists("get_page_complete_config") && is.function(get_page_complete_config))
      # page_config <- tryCatch(
      #   {
      #     get_page_complete_config(id) # Load config based on current page id
      #   },
      #   error = function(e) {
      #     warning(paste("Error loading page config for", id, ":", e$message))
      #     NULL
      #   }
      # )
      # req(page_config) # Stop if config loading failed

      # Initial UI state checks - these need to be outside the reactive
      # as they depend on input$ values directly related to visibility.
      # We'll check them inside the render functions instead.
      # req(input$visualization_state == "visible", cancelOutput = TRUE)
      # req(input$display_type == "plot", cancelOutput = TRUE)

      # Use the reactive values defined outside for this render execution
      current_settings <- current_settings_reactive()
      current_sim_id <- current_sim_id_reactive()

      # Validate settings and sim ID
      req(current_settings, !is.null(current_settings$outcomes), cancelOutput = TRUE)
      req(!is.null(current_sim_id), cancelOutput = TRUE)

      # Get visualization config
      vis_config <- tryCatch(get_component_config("visualization"), error = function(e) {
        warning("Error loading visualization config: ", e$message)
        NULL
      })
      backend <- vis_config$plotting_backend %||% "ggplot"

      # Get current simulation and check for errors
      sim_state_check <- store$get_simulation(current_sim_id)
      if (is.null(sim_state_check) || sim_state_check$status == "error") {
        err_msg <- if (is.null(sim_state_check)) "No sim" else sim_state_check$error_message %||% "Sim error"
        return(list(error = TRUE, error_message = err_msg, error_type = ERROR_TYPES$SIMULATION, sim_settings = NULL)) # Return NULL for sim_settings on error
      }

      # Get simulation data
      sim_state_data <- store$get_current_simulation_data(id)
      if (is.null(sim_state_data) || is.null(sim_state_data$simset)) {
        err_msg <- "No sim data."
        return(list(error = TRUE, error_message = err_msg, error_type = ERROR_TYPES$PLOT, sim_settings = sim_state_check$settings)) # Return settings even on plot error
      }

      # Get baseline simulation if applicable
      sim_settings <- sim_state_check$settings
      req(sim_settings) # Should exist if sim_state_check is valid

      baseline_simset <- NULL
      if (id == "custom") {
        baseline_simset <- store$get_original_base_simulation(id)
      }
      if (is.null(baseline_simset)) {
        baseline_simset <- tryCatch(load_baseline_simulation(id, sim_settings), error = function(e) {
          warning("Error loading baseline simulation: ", e$message)
          NULL
        })
      }

      # --- Determine Data Manager ---
      data_manager_to_use <- NULL
      data_manager_path <- vis_config$data_manager_path # Read path from config
      if (!is.null(data_manager_path) && nzchar(data_manager_path) && file.exists(data_manager_path)) {
        tryCatch(
          {
            temp_env <- new.env(parent = emptyenv())
            loaded_names <- load(data_manager_path, envir = temp_env)
            if (length(loaded_names) == 1) {
              loaded_obj <- temp_env[[loaded_names[1]]]
              # Basic check if it looks like a data manager (adjust class name if needed)
              if (inherits(loaded_obj, "jheem.data.manager")) {
                data_manager_to_use <- loaded_obj
                # print(paste("Using data manager loaded from:", data_manager_path)) # Keep commented
              } else {
                warning(paste("Object loaded from", data_manager_path, "is not a jheem.data.manager object."))
              }
            } else {
              warning(paste("Expected one object in", data_manager_path, "but found", length(loaded_names)))
            }
          },
          error = function(e) {
            warning(paste("Error loading data manager from", data_manager_path, ":", e$message))
          }
        )
      }

      # Fallback to default if not loaded
      if (is.null(data_manager_to_use)) {
        # print("Using default data manager.") # Keep commented
        # Ensure get.default.data.manager() exists and is accessible
        if (exists("get.default.data.manager") && is.function(get.default.data.manager)) {
          data_manager_to_use <- get.default.data.manager()
        } else {
          warning("get.default.data.manager function not found. Cannot set data manager.")
          # Handle error appropriately - maybe return error state from reactive?
          return(list(error = TRUE, error_message = "Default data manager function not found.", error_type = ERROR_TYPES$PLOT, sim_settings = sim_settings))
        }
      }
      # Ensure data_manager_to_use is not NULL before proceeding
      req(data_manager_to_use)

      # Set up plot arguments (common args)
      plot_args <- list(
        outcomes = current_settings$outcomes,
        facet.by = current_settings$facet.by,
        data.manager = data_manager_to_use, # Add the selected data manager
        summary.type = current_settings$summary.type
        # style.manager will be added conditionally later
      )

      # Prepare sim list or single simset
      sim_list_or_simset <- NULL
      if (!is.null(baseline_simset)) {
        # Determine Intervention Label Dynamically
        intervention_label <- "Intervention" # Default
        if (id == "prerun") {
          # For prerun page, use the scenario name from the loaded simulation's settings
          selected_scenario_value <- sim_state_check$settings$scenario # Get scenario ID from stored settings
          if (!is.null(selected_scenario_value) && nzchar(selected_scenario_value)) {
            # Find the display label using the passed scenario_options_config
            # scenario_options_config should be PRERUN_CONFIG$selectors$scenario$options
            if (!is.null(scenario_options_config)) {
              # Options are named lists: key=id, value=list(id=..., label=...)
              option_match <- scenario_options_config[[selected_scenario_value]]
              if (!is.null(option_match) && !is.null(option_match$label)) {
                intervention_label <- option_match$label
              } else {
                # Fallback if direct key lookup fails
                warning(paste("Could not find display label for scenario value:", selected_scenario_value))
                intervention_label <- selected_scenario_value # Fallback to value
              }
            } else {
              warning("Scenario options config was not passed to plot_panel_server.")
              intervention_label <- selected_scenario_value # Fallback
            }
          } else {
            warning("Scenario value not found in loaded simulation settings. Using default label.")
            # Keep default "Intervention" (already set above)
          }
        } else {
          # For other pages (e.g., custom), always use "Intervention"
          intervention_label <- "Intervention"
        }

        # Determine Baseline Label - Force to "Baseline"
        baseline_label <- "Baseline"

        # Create the list with determined labels
        sim_list <- list()
        sim_list[[baseline_label]] <- baseline_simset
        sim_list[[intervention_label]] <- sim_state_data$simset # Use determined label
        sim_list_or_simset <- sim_list
      } else {
        sim_list_or_simset <- list(sim_state_data$simset) # Pass as a list even if single
        # Adjust naming if needed, maybe use simset name or a default
        names(sim_list_or_simset) <- names(sim_list_or_simset) %||% "Simulation"
      }

      # Return prepared data
      list(
        error = FALSE,
        vis_config = vis_config,
        backend = backend,
        plot_args = plot_args,
        sim_list_or_simset = sim_list_or_simset,
        sim_settings = sim_settings # Pass sim_settings for title generation
        # sim_state_check and sim_state_data are implicitly used above
      )
    })

    # --- ggplot Rendering ---
    output$mainPlot <- bindCache( # Apply bindCache *around* renderPlot
      renderPlot(
        {
          # Check visibility first
          req(input$visualization_state == "visible", cancelOutput = TRUE)
          req(input$display_type == "plot", cancelOutput = TRUE)

          # --- Check if plot control settings have changed ---
          current_settings <- current_settings_reactive() # Get current settings
          req(current_settings) # Ensure settings are available
          if (isTRUE(identical(current_settings, last_rendered_settings()))) {
            # print("[PLOT PANEL - ggplot] Plot settings identical to last render. Skipping re-render.") # Keep commented
            session$sendCustomMessage("plotRendered", list()) # Signal JS to hide overlay
            req(FALSE, cancelOutput = TRUE) # Stop execution, keep cached plot
          }
          # --- End no-change check ---

          # Get prepared data
          plot_data <- plot_data_reactive()

          # Check for initial errors from reactive
          if (isTRUE(plot_data$error)) {
            sim_boundary$set_error(
              message = plot_data$error_message,
              type = plot_data$error_type,
              severity = SEVERITY_LEVELS$ERROR
            )
            vis_manager$set_plot_status("error")
            direct_error_message(paste("Error:", plot_data$error_message))
            return(NULL)
          }

          # Check if backend is ggplot
          req(plot_data$backend == "ggplot", cancelOutput = TRUE)

          # Set loading status
          vis_manager$set_plot_status("loading")

          # Generate the plot
          generated_plot <- tryCatch(
            {
              # Ensure required functions exist
              req(
                exists("create_style_manager_from_config") && is.function(create_style_manager_from_config),
                exists("customize_plot_from_config") && is.function(customize_plot_from_config),
                exists("simplot") && is.function(simplot)
              )

              # Get plot args from reactive data
              plot_args_final <- plot_data$plot_args

              # Add style manager for ggplot
              style_manager <- create_style_manager_from_config(plot_data$vis_config)
              if (!is.null(style_manager)) {
                plot_args_final$style.manager <- style_manager
              }

              # Call simplot
              the_plot <- do.call(simplot, c(plot_data$sim_list_or_simset, plot_args_final))
              req(the_plot)

              # Apply ggplot customizations
              the_plot <- customize_plot_from_config(the_plot, plot_data$vis_config)
              req(the_plot)

              # Clear errors and set status
              sim_boundary$clear()
              plot_boundary$clear()
              validation_boundary$clear()
              store$clear_page_error_state(id)
              vis_manager$set_plot_status("ready")
              direct_error_message(NULL)

              # Send explicit plot complete message
              session$sendCustomMessage("plot_progress_complete", list())

              # REMOVED: Explicitly hide loading overlay as a failsafe
              # session$sendCustomMessage("hideLoadingOverlay", list())

              # Store the settings used for this successful render
              last_rendered_settings(current_settings)

              the_plot
            },
            error = function(e) {
              err_msg <- conditionMessage(e)
              plot_boundary$set_error(message = err_msg, type = ERROR_TYPES$PLOT, severity = SEVERITY_LEVELS$ERROR)
              store$update_page_error_state(id, has_error = TRUE, message = err_msg, type = ERROR_TYPES$PLOT, severity = SEVERITY_LEVELS$ERROR)
              vis_manager$set_plot_status("error")
              direct_error_message(paste("Error:", err_msg))
              # Send plot error message
              session$sendCustomMessage("plot_progress_error", list(message = err_msg))

              # REMOVED: Hide loading overlay on error (JS timeout will handle it)
              # session$sendCustomMessage("hideLoadingOverlay", list())

              NULL
            }
          ) # end tryCatch
          return(generated_plot)
        },
        res = 96
      ), # End renderPlot expression
      # Cache key arguments for bindCache:
      id,
      current_settings_reactive(),
      current_sim_id_reactive()
    ) # End bindCache

    # --- Plotly Rendering ---
    output$mainPlotly <- renderPlotly({
      # Check visibility first
      req(input$visualization_state == "visible", cancelOutput = TRUE)
      req(input$display_type == "plot", cancelOutput = TRUE)

      # --- Check if plot control settings have changed ---
      current_settings <- current_settings_reactive() # Get current settings
      req(current_settings) # Ensure settings are available
      if (isTRUE(identical(current_settings, last_rendered_settings()))) {
        # print("[PLOT PANEL - plotly] Plot settings identical to last render. Skipping re-render.") # Keep commented
        session$sendCustomMessage("plotRendered", list()) # Signal JS to hide overlay
        req(FALSE, cancelOutput = TRUE) # Stop execution, keep cached plot
      }
      # --- End no-change check ---
      # Get prepared data
      plot_data <- plot_data_reactive()

      # Check for initial errors from reactive
      if (isTRUE(plot_data$error)) {
        sim_boundary$set_error(
          message = plot_data$error_message,
          type = plot_data$error_type,
          severity = SEVERITY_LEVELS$ERROR
        )
        vis_manager$set_plot_status("error")
        direct_error_message(paste("Error:", plot_data$error_message))
        return(NULL) # Return empty plotly object on error? Or just NULL?
      }

      # Check if backend is plotly
      req(plot_data$backend == "plotly", cancelOutput = TRUE)

      # Set loading status
      vis_manager$set_plot_status("loading")

      # Generate the plot
      generated_plotly_plot <- tryCatch(
        {
          # Ensure required functions exist
          req(
            exists("create_style_manager_from_config") && is.function(create_style_manager_from_config), # Still needed? plot.simulations might use it differently
            exists("plot.simulations_local") && is.function(plot.simulations_local) # Check for local version
          )

          # Get plot args from reactive data
          plot_args_final <- plot_data$plot_args

          # Add style manager - plot.simulations might expect it
          # Using the same function, but plot.simulations might interpret it differently
          style_manager <- create_style_manager_from_config(plot_data$vis_config)
          if (!is.null(style_manager)) {
            plot_args_final$style.manager <- style_manager
          }

          # Call plot.simulations_local
          the_plotly_plot <- do.call(plot.simulations_local, c(plot_data$sim_list_or_simset, plot_args_final)) # Call local version
          req(the_plotly_plot)

          # --- DO NOT APPLY ggplot customizations ---
          # the_plot <- customize_plot_from_config(the_plot, plot_data$vis_config)

          # Clear errors and set status
          sim_boundary$clear()
          plot_boundary$clear()
          validation_boundary$clear()
          store$clear_page_error_state(id)
          vis_manager$set_plot_status("ready")
          direct_error_message(NULL)

          # Send explicit plot complete message
          session$sendCustomMessage("plot_progress_complete", list())

          # REMOVED: Explicitly hide loading overlay as a failsafe
          # session$sendCustomMessage("hideLoadingOverlay", list())

          # Store the settings used for this successful render
          last_rendered_settings(current_settings)

          the_plotly_plot
        },
        error = function(e) {
          err_msg <- conditionMessage(e)
          plot_boundary$set_error(message = err_msg, type = ERROR_TYPES$PLOT, severity = SEVERITY_LEVELS$ERROR)
          store$update_page_error_state(id, has_error = TRUE, message = err_msg, type = ERROR_TYPES$PLOT, severity = SEVERITY_LEVELS$ERROR)
          vis_manager$set_plot_status("error")
          direct_error_message(paste("Error:", err_msg))
          # Send plot error message
          session$sendCustomMessage("plot_progress_error", list(message = err_msg))

          # REMOVED: Hide loading overlay on error (JS timeout will handle it)
          # session$sendCustomMessage("hideLoadingOverlay", list())

          NULL # Return empty plotly object on error?
        }
      ) # end tryCatch
      return(generated_plotly_plot)
    }) # End renderPlotly

    # --- GGPlotly Rendering ---
    output$mainGGPlotly <- bindCache( # Apply bindCache *around* renderPlotly
      renderPlotly({
        # Check visibility first
        req(input$visualization_state == "visible", cancelOutput = TRUE)
        req(input$display_type == "plot", cancelOutput = TRUE)

        # REMOVED: Check for identical settings to prevent re-render.
        # We want the plot to re-render if the underlying data (sim_id) changes,
        # even if the plot controls haven't.
        # --- End no-change check ---

        # Get prepared data
        plot_data <- plot_data_reactive()
        # Get current settings for use later (e.g., in last_rendered_settings)
        current_settings <- current_settings_reactive()
        req(current_settings) # Ensure settings are available

        # Check for initial errors from reactive
        if (isTRUE(plot_data$error)) {
          sim_boundary$set_error(
            message = plot_data$error_message,
            type = plot_data$error_type,
            severity = SEVERITY_LEVELS$ERROR
          )
          vis_manager$set_plot_status("error")
          direct_error_message(paste("Error:", plot_data$error_message))
          return(NULL)
        }

        # Check if backend is ggplotly
        req(plot_data$backend == "ggplotly", cancelOutput = TRUE)

        # Set loading status
        vis_manager$set_plot_status("loading")

        # Generate the plot
        generated_ggplotly_plot <- tryCatch(
          {
            # Ensure required functions exist
            req(
              exists("create_style_manager_from_config") && is.function(create_style_manager_from_config),
              exists("customize_plot_from_config") && is.function(customize_plot_from_config),
              exists("simplot") && is.function(simplot)
            )

            # Get plot args from reactive data
            plot_args_final <- plot_data$plot_args
            plot_args_final$append.url <- TRUE # Add append.url argument
            # Explicitly set title to NULL to prevent simplot from adding one # REMOVED THIS LINE
            # print("[PLOT PANEL - ggplotly] Setting title = NULL in simplot args.") # REMOVED THIS LINE

            # Add style manager for ggplot, passing simplify_legend flag
            # simplify_flag <- length(plot_data$sim_list_or_simset) == 2 # simplify_legend not used currently
            style_manager <- create_style_manager_from_config(plot_data$vis_config) # simplify_legend = simplify_flag)
            if (!is.null(style_manager)) {
              plot_args_final$style.manager <- style_manager
            }

            # NEW: Create and add the custom facet labeller
            custom_labeller <- create_custom_facet_labeller(
              label_mappings = plot_data$vis_config$facet_labels,
              original_facet_vars = plot_data$plot_args$facet.by
            )
            if (!is.null(custom_labeller)) {
              plot_args_final$facet_labeller <- custom_labeller
            }

            # Call LOCAL simplot to get ggplot object
            the_ggplot <- do.call(simplot_local, c(plot_data$sim_list_or_simset, plot_args_final))
            req(the_ggplot)

            # Force remove title potentially added by simplot (handled by UI now)
            the_ggplot <- the_ggplot + theme(plot.title = element_blank()) # RE-ADD THIS LINE

            # Calculate number of lines needed for facet labels
            num_facet_lines <- 1 # Start with 1 for the outcome name
            if (!is.null(plot_data$plot_args$facet.by)) {
              num_facet_lines <- num_facet_lines + length(plot_data$plot_args$facet.by)
            }
            # print(paste("[PLOT PANEL - ggplotly] Calculated num_facet_lines:", num_facet_lines)) # Keep commented

            # Apply ggplot customizations, passing the number of lines
            the_ggplot <- customize_plot_from_config(the_ggplot, plot_data$vis_config, num_facet_lines = num_facet_lines)
            req(the_ggplot)

            # Add debugging for ribbon investigation
            has_ribbon_geom <- FALSE
            ribbon_data_list <- list()
            ribbon_layers <- c()

            # Check if the plot contains ribbon geoms
            if (length(the_ggplot$layers) > 0) {
              for (i in 1:length(the_ggplot$layers)) {
                if (inherits(the_ggplot$layers[[i]]$geom, "GeomRibbon")) {
                  has_ribbon_geom <- TRUE
                  # print(paste("Found GeomRibbon in layer", i)) # Keep commented

                  # Try to extract ribbon data
                  ribbon_data <- suppressWarnings(ggplot2::layer_data(the_ggplot, i))
                  # print("Ribbon columns:") # Keep commented
                  # print(names(ribbon_data)) # Keep commented
                  # print("First few rows:") # Keep commented
                  # print(head(ribbon_data)) # Keep commented

                  # Store ribbon data for later use
                  ribbon_data_list[[length(ribbon_data_list) + 1]] <- ribbon_data
                  ribbon_layers <- c(ribbon_layers, i)
                }
              }

              if (!has_ribbon_geom) {
                # print("No GeomRibbon found in plot layers") # Keep commented
                # print("Layer classes:") # Keep commented
                # print(sapply(the_ggplot$layers, function(x) class(x$geom)[1])) # Keep commented
              }
            }

            # Force 2-column layout by explicitly modifying the facet
            if (inherits(the_ggplot$facet, "FacetWrap")) {
              # Directly modify the facet parameters to use 2 columns
              the_ggplot$facet$params$ncol <- 2

              # Calculate rows based on number of panels
              facet_layout <- ggplot2::ggplot_build(the_ggplot)$layout$layout
              n_facets <- nrow(facet_layout)
              n_rows <- ceiling(n_facets / 2)

              # Set calculated height based on number of rows
              pixels_per_row <- 250 # Estimated height per row
              buffer_pixels <- 250 # Increased extra space for title, legend, etc.
              calculated_height <- (n_rows * pixels_per_row) + buffer_pixels
            } else {
              # Default height if no facets
              calculated_height <- 600
            }

            # --- REMOVED Manual Ribbon Recreation Loop ---
            # This is no longer needed as execute_simplot_local now uses standard geom_ribbon.

            # Explicitly NULLify the title label before ggplotly conversion
            # print("[PLOT PANEL - ggplotly] Setting plot$labels$title to NULL before ggplotly()") # Keep commented
            the_ggplot$labels$title <- NULL

            # Convert to plotly with explicit height
            plotly_fig <- plotly::ggplotly(the_ggplot,
              height = calculated_height,
              tooltip = "text" # Use the 'text' aesthetic from simplot_local
            )

            # Apply Plotly workarounds using helper functions
            plotly_fig <- simplify_plotly_legend(plotly_fig, names(plot_data$sim_list_or_simset))
            plotly_fig <- adjust_plotly_facet_labels(plotly_fig, adjustment_offset = 0.01)

            # GGPLOTLY OVERRIDE: Manually position legend at the top for ggplotly backend,
            # overriding the theme setting from visualization.yaml which may not translate correctly.
            # Position legend at the top, horizontally
            plotly_fig <- plotly_fig %>% layout(legend = list(
              orientation = "h", # Horizontal layout
              yanchor = "bottom", # Anchor legend bottom to y position
              y = 1.02, # Position slightly above plot area (adjust as needed)
              xanchor = "center", # Anchor legend center to x position
              x = 0.5 # Center horizontally
            ))

            # Clear errors and set status
            sim_boundary$clear()
            plot_boundary$clear()
            validation_boundary$clear()
            store$clear_page_error_state(id)
            vis_manager$set_plot_status("ready")
            direct_error_message(NULL)

            # Send explicit plot complete message
            session$sendCustomMessage("plot_progress_complete", list())

            # Store the settings used for this successful render
            last_rendered_settings(current_settings)

            plotly_fig
          },
          error = function(e) {
            err_msg <- conditionMessage(e)
            plot_boundary$set_error(message = err_msg, type = ERROR_TYPES$PLOT, severity = SEVERITY_LEVELS$ERROR)
            store$update_page_error_state(id, has_error = TRUE, message = err_msg, type = ERROR_TYPES$PLOT, severity = SEVERITY_LEVELS$ERROR)
            vis_manager$set_plot_status("error")
            direct_error_message(paste("Error:", err_msg))
            # Send plot error message
            session$sendCustomMessage("plot_progress_error", list(message = err_msg))
            NULL
          }
        ) # end tryCatch
        return(generated_ggplotly_plot)
      }), # End renderPlotly expression
      # Cache key arguments for bindCache:
      id,
      current_settings_reactive(),
      current_sim_id_reactive()
    ) # End bindCache

    # --- Visibility Observer (Handles Reset Only) ---
    observeEvent(list(input$visualization_state, input$display_type),
      {
        state <- input$visualization_state
        display <- input$display_type
        id_log_prefix <- paste0("-[ PlotVisDisp", id, " ]-")
        panel_type <- "plot"

        if (!(state == "visible" && display == panel_type)) {
          if (!is.null(isolate(direct_error_message())) ||
            isolate(store$get_plot_status(id) == "loading")) {
            # print(paste0(id_log_prefix, " Deactivating. Resetting local state...")) # Commented out
            isolate({
              vis_manager$reset()
              validation_boundary$clear()
              plot_boundary$clear()
              sim_boundary$clear()
              direct_error_message(NULL)
              store$set_plot_status(id, "ready")
            })
          }
        } else {
          # print(paste0(id_log_prefix, " State is active. renderPlot will run.")) # Commented out
          isolate(direct_error_message(NULL))
        }
      },
      ignoreNULL = TRUE,
      ignoreInit = TRUE
    )

    # --- Button Observer (Updates control_manager ONLY) ---
    observeEvent(input$update_visualization, {
      req(input$update_visualization > 0)
      req(input$visualization_state == "visible")
      req(input$display_type == "plot")

      # Send message to JS to show the plot progress indicator
      session$sendCustomMessage("plot_progress_start", list(description = "Updating Visualization"))

      # REMOVED: Old way of showing overlay via direct JS call
      # session$sendCustomMessage("javascript",
      #   sprintf("if(window.showLoadingOverlay) { window.showLoadingOverlay('%s'); }", id))

      # Set loading status (R side)
      vis_manager$set_plot_status("loading")

      new_settings <- isolate({
        outcomes <- input[[paste0("outcomes_", id)]]
        facet_by_in <- input[[paste0("facet_by_", id)]]
        summary_type <- input[[paste0("summary_type_", id)]]

        valid <- TRUE

        if (is.null(outcomes) || length(outcomes) == 0 || all(outcomes == "")) {
          showNotification("Select outcome.", type = "warning")
          valid <- FALSE
        }

        if (is.null(summary_type) || summary_type == "") {
          showNotification("Select summary.", type = "warning")
          valid <- FALSE
        }

        if (!valid) {
          return(NULL)
        }

        facet_value <- if (!is.null(facet_by_in) &&
          length(facet_by_in) > 0 &&
          !all(facet_by_in == "")) {
          as.character(facet_by_in)
        } else {
          NULL
        }

        list(
          outcomes = as.character(outcomes),
          facet.by = facet_value,
          summary.type = summary_type
        )
      })

      if (!is.null(new_settings)) {
        # Compare with last rendered settings
        if (isTRUE(identical(new_settings, last_rendered_settings()))) {
          # print(paste0("-[ PlotButton", id, " ]- Settings identical to last render. Skipping update.")) # Keep commented
          session$sendCustomMessage("plot_progress_complete", list()) # Signal JS as complete immediately
          vis_manager$set_plot_status("ready") # Set status back to ready
          return() # Stop observer execution
        } else {
          # Settings are different, proceed with update
          # print(paste0("-[ PlotButton", id, " ]- Updating control_manager ONLY...")) # Commented out
          # str(new_settings) # Commented out
          control_manager$update_settings(new_settings)
        }
      } else {
        # Validation failed earlier
        # print(paste0("-[ PlotButton", id, " ]- Settings validation failed.")) # Keep commented
        # Ensure overlay is hidden if validation fails *after* setting loading
        vis_manager$set_plot_status("ready") # Set back to ready if validation failed
        session$sendCustomMessage("plot_progress_error", list(message = "Input validation failed")) # Signal JS error
      }
    })

    # --- Error handling & Debug observers ---
    observe({
      sim_id <- isolate(store$get_current_simulation_id(id))
      sim_state <- if (!is.null(sim_id)) isolate(store$get_simulation(sim_id)) else NULL

      isolate({
        if (!is.null(sim_state) &&
          sim_state$status == "error" &&
          !is.null(sim_state$error_message)) {
          err_msg <- sprintf("Error: %s", as.character(sim_state$error_message))

          if (is.null(direct_error_message()) || direct_error_message() != err_msg) {
            # print(paste0("-[ PlotSimObserver", id, " ]- Sim error: ", err_msg)) # Keep print for actual error

            sim_boundary$set_error(
              message = sim_state$error_message,
              type = ERROR_TYPES$SIMULATION,
              severity = SEVERITY_LEVELS$ERROR
            )

            direct_error_message(err_msg)
            store$set_plot_status(id, "error")
          }
        }
      })
    })

    observe({
      page_error_state <- isolate(store$get_page_error_state(id))

      isolate({
        if (page_error_state$has_error && !is.null(page_error_state$message)) {
          err_msg <- sprintf("Error: %s", page_error_state$message)

          if (is.null(direct_error_message()) || direct_error_message() != err_msg) {
            # print(paste0("-[ PlotPersistObserver", id, " ]- Syncing global error: ", err_msg)) # Keep print for actual error

            error_type <- page_error_state$type %||% ERROR_TYPES$SIMULATION
            boundary_to_use <- switch(error_type,
              SIMULATION = sim_boundary,
              PLOT = plot_boundary,
              VALIDATION = validation_boundary,
              sim_boundary
            )

            if (!is.null(boundary_to_use)) {
              boundary_to_use$set_error(
                message = page_error_state$message,
                type = error_type,
                severity = page_error_state$severity %||% SEVERITY_LEVELS$ERROR
              )
            }

            direct_error_message(err_msg)
            store$set_plot_status(id, "error")
          }
        }
      })
    })

    last_error_state <- reactiveVal(list(has_error = FALSE, message = NULL))

    observe({
      error_state <- if (!is.null(sim_boundary)) isolate(sim_boundary$get_state()) else NULL
      error_visible <- !is.null(error_state) && error_state$has_error

      current_direct_error <- direct_error_message()
      has_direct_error <- !is.null(current_direct_error) && nzchar(current_direct_error)

      current <- list(
        has_error = error_visible,
        message = if (error_visible) error_state$message else NULL,
        direct_error = has_direct_error
      )

      prev <- last_error_state()

      if (!identical(current, prev)) {
        if (error_visible || has_direct_error) {
          # print(sprintf( # Keep commented
          #   "[DEBUG_PLOT][%s] Error boundary:%s Direct:%s",
          #   id,
          #   if (error_visible) "VISIBLE" else "HIDDEN",
          #   if (has_direct_error) "VISIBLE" else "HIDDEN"
          # ))
        }

        last_error_state(current)
      }
    })

    # --- Client-side Plot Download Handler ---
    observeEvent(input$downloadPlotClient, {
      req(input$downloadPlotClient > 0) # Ensure button was actually clicked
      # browser() # Pause execution here for debugging - REMOVING FOR NOW

      # Determine the active plot output ID based on backend
      vis_config <- tryCatch(get_component_config("visualization"), error = function(e) {
        warning(paste("Error getting visualization config:", e$message))
        NULL
      })
      backend <- vis_config$plotting_backend %||% "ggplot" # Default to ggplot

      plot_output_id <- NULL
      if (backend == "plotly") {
        plot_output_id <- ns("mainPlotly")
      } else if (backend == "ggplotly") {
        plot_output_id <- ns("mainGGPlotly")
      } else {
        # Backend is ggplot, cannot download via Plotly.js
        showNotification("Plot download is only available for Plotly backends.", type = "warning")
        return()
      }

      # Construct dynamic filename
      current_plot_data <- plot_data_reactive()
      current_plot_settings <- current_settings_reactive()

      location <- "unknown_location"
      if (!is.null(current_plot_data$sim_settings) && !is.null(current_plot_data$sim_settings$location)) {
        location <- current_plot_data$sim_settings$location
      }
      location_clean <- gsub("[^A-Za-z0-9_-]", "_", location)

      scenario_name_clean <- ""
      if (id == "prerun") {
        # Logic to get scenario name for prerun (from intervention_label in plot_data_reactive)
        # This relies on sim_list_or_simset being named appropriately
        sim_names <- names(current_plot_data$sim_list_or_simset)
        if (length(sim_names) > 1 && sim_names[1] == "Baseline" && !is.null(sim_names[2])) {
          scenario_name_clean <- gsub("[^A-Za-z0-9_-]", "_", sim_names[2])
        } else if (length(sim_names) == 1 && !is.null(sim_names[1])) {
          # If only one simset, it might be the intervention itself
          scenario_name_clean <- gsub("[^A-Za-z0-9_-]", "_", sim_names[1])
        } else {
          # Fallback if names are not as expected, try to get from settings$scenario
          if (!is.null(current_plot_data$sim_settings$scenario) && nzchar(current_plot_data$sim_settings$scenario)) {
            # Try to get the label from PRERUN_CONFIG if available globally
            prerun_scenario_options <- NULL
            if (exists("PRERUN_CONFIG") && !is.null(PRERUN_CONFIG$selectors$scenario$options)) {
              prerun_scenario_options <- PRERUN_CONFIG$selectors$scenario$options
            }
            scenario_val <- current_plot_data$sim_settings$scenario
            if (!is.null(prerun_scenario_options) && !is.null(prerun_scenario_options[[scenario_val]]$label)) {
              scenario_name_clean <- gsub("[^A-Za-z0-9_-]", "_", prerun_scenario_options[[scenario_val]]$label)
            } else {
              scenario_name_clean <- gsub("[^A-Za-z0-9_-]", "_", scenario_val) # Fallback to scenario id
            }
          }
        }
      } else if (id == "custom") {
        scenario_name_clean <- "CustomSim" # Placeholder for custom scenarios
        # TODO: Later, extract key custom intervention parameters here
        # For example, date ranges if available in current_plot_data$sim_settings or current_plot_settings
      }

      facets_clean <- "NoFacets"
      if (!is.null(current_plot_settings$facet.by) && length(current_plot_settings$facet.by) > 0) {
        facets_clean <- paste(sapply(current_plot_settings$facet.by, function(f) gsub("[^A-Za-z0-9_-]", "_", f)), collapse = "-")
      }

      summary_type_clean <- "NoSummary"
      if (!is.null(current_plot_settings$summary.type) && nzchar(current_plot_settings$summary.type)) {
        summary_type_clean <- gsub("[^A-Za-z0-9_-]", "_", current_plot_settings$summary.type)
      }

      timestamp <- format(Sys.time(), "%H%M%S")

      filename_parts <- c(
        "jheem_plot",
        id,
        location_clean
      )
      if (nzchar(scenario_name_clean)) {
        filename_parts <- c(filename_parts, scenario_name_clean)
      }
      filename_parts <- c(
        filename_parts,
        facets_clean,
        summary_type_clean,
        Sys.Date(),
        timestamp
      )

      # Construct base filename WITHOUT .png extension
      base_filename <- paste(filename_parts, collapse = "_")

      # Send message to JavaScript handler
      session$sendCustomMessage("downloadPlotly", list(
        plotId = plot_output_id,
        filename = base_filename, # JS will add .png based on format
        scale = 2,
        format = "png" # Explicitly tell JS the format for extension
      ))
    })
  }) # END moduleServer
}
